///////////////////////////////////////////////////////////////////////////////
// Signal Type Logic Scripts
//
///////////////////////////////////////////////////////////////////////////////
SCRIPT LNER_Searchlightc

// LNER 2 Aspect Searchlight (Distant)

	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	dist_multi_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if ( //!enabled ||							// Not enabled/cleared to show natural state?
		!route_set() ||							// Switch not set as per link?
		dist_multi_sig_mr (SIGFN_NORMAL, SIGFN_DISTANCE) ==# SIGASP_STOP)
	{
		state = SIGASP_APPROACH_2;
	}
	else
	{
		state = SIGASP_CLEAR_2;
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////

SCRIPT LNER_Searchlight

// LNER 4 Aspect Searchlight

extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

// If required, show the 'stop' indication.
	if (!enabled ||								// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR ||				// Block ahead not clear?
		!route_set())							// Switch not set as per link?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP ||
			next_state ==# SIGASP_STOP_AND_PROCEED ||
			next_state ==# SIGASP_RESTRICTING)
		{
			state = SIGASP_APPROACH_1;
		}
		else if (next_state ==# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_2;
		}
		else //if (next_state ==# SIGASP_APPROACH_2 ||
			//	next_state ==# SIGASP_CLEAR_2)
		{
			state = SIGASP_CLEAR_2;
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT LNER_Searchlighta

// LNER 3 Aspect Searchlight

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

// If required, show the 'stop' indication.
	if (!enabled ||								// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR ||				// Block ahead not clear?
		!route_set())							// Switch not set as per link?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else
      {
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP ||
			next_state ==# SIGASP_STOP_AND_PROCEED ||
			next_state ==# SIGASP_RESTRICTING)
		{
			state = SIGASP_APPROACH_1;
		}
		else if (next_state ==# SIGASP_APPROACH_2)
		{
			state = SIGASP_CLEAR_2;
		}
		else //if (next_state ==# SIGASP_APPROACH_2 ||
			//	next_state ==# SIGASP_CLEAR_2)
		{
			state = SIGASP_CLEAR_2;
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT LNER_Searchlightb

// LNER 2 Aspect Searchlight

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

// If required, show the 'stop' indication.
	if (!enabled ||								// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR ||				// Block ahead not clear?
		!route_set())							// Switch not set as per link?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else
      {
		state = SIGASP_CLEAR_2;
	}

// Get draw state
	draw_state = def_draw_state (state);

// End of File
