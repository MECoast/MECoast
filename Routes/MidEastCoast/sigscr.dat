///////////////////////////////////////////////////////////////////////////////
SCRIPT UKGroundSig

// UK Ground Signal

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

if(block_state()==#BLOCK_OCCUPIED&&TrainHasCallOn_Restricted()&&route_set() )
{
state = SIGASP_STOP_AND_PROCEED;
}
else

	if (!enabled ||	block_state() !=# BLOCK_CLEAR)		
	{
		state = SIGASP_STOP;
	}
	else
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP ||
			next_state ==# SIGASP_STOP_AND_PROCEED ||
			next_state ==# SIGASP_RESTRICTING)
		{
			state = SIGASP_RESTRICTING;
		}
		else if (next_state ==# SIGASP_APPROACH_1)
		{
			state = SIGASP_RESTRICTING;
		}
		else //if (next_state ==# SIGASP_APPROACH_2 ||
			//	next_state ==# SIGASP_CLEAR_2)
		{
			state = SIGASP_RESTRICTING;
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT BR_M_Ground_Dollyyellow

// BR Semaphore Ground Disc Yellow

	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	dist_multi_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if ( //!enabled ||							// Not enabled/cleared to show natural state?
		!route_set() ||							// Switch not set as per link?
		dist_multi_sig_mr (SIGFN_NORMAL, SIGFN_DISTANCE) !=# SIGASP_CLEAR_1)
	{
		state = SIGASP_APPROACH_1;
	}
	else
	{
		state = SIGASP_CLEAR_1;
	}

// Get draw state
	draw_state = def_draw_state (state);


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

SCRIPT BR_M_Ground_Dolly

// BR Semaphore Ground Disc

	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

if(block_state()==#BLOCK_OCCUPIED&&TrainHasCallOn_Restricted()&&route_set() )
{
state = SIGASP_STOP_AND_PROCEED;
}
else if(block_state()!=#BLOCK_CLEAR||!enabled||!route_set())
{
state = SIGASP_STOP;
}
else 
{
state = SIGASP_CLEAR_1;
}
draw_state = def_draw_state (state);


///////////////////////////////////////////////////////////////////////////////
SCRIPT BRSemHome

	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;


if(block_state()==#BLOCK_OCCUPIED&&TrainHasCallOn_Restricted()&&route_set() )
{
state = SIGASP_STOP_AND_PROCEED;
}
else if(block_state()!=#BLOCK_CLEAR||!enabled||!route_set())
{
state = SIGASP_STOP;
}
else 
{
state = SIGASP_CLEAR_2;
}

draw_state = def_draw_state (state);


///////////////////////////////////////////////////////////////////////////////
SCRIPT BRSemDist

// Upper Quad Distant Modified by Mick Clarke, February 2013

	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	dist_multi_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	next_sig_lr ();

// dist_multi_sig_mr returns SIGASP_STOP if a trailing switch ahead stops the path to the
// following distant, giving an incorrect clear aspect on single track to multiple track and 
// back to single track layouts. route_set only works on diverging linked signals, therefore 
// next_sig_lr is required to get the state of next home signal.// IMPORTANT The last distant
// before the trailing switch must have only one home before the switch.

	if (	!route_set() ||	// Switch not set as per link
		dist_multi_sig_mr (SIGFN_NORMAL, SIGFN_DISTANCE) !=# SIGASP_CLEAR_2)  // Normal stop sig check
	{
		state = SIGASP_APPROACH_2;
	}
	else if ( next_sig_lr (SIGFN_NORMAL) !=# SIGASP_CLEAR_2) //Next Home Signal not clear
	{
		state = SIGASP_APPROACH_2;
	}
	else
	{
		state = SIGASP_CLEAR_2;
	}

// Get draw state
	draw_state = def_draw_state (state);


///////////////////////////////////////////////////////////////////////////////
SCRIPT BRSemHomeDistComb

// Upper Quad Home and Distant Modified by Mick Clarke, February 2013

	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	dist_multi_sig_mr ();
	extern float	state;
	extern float	draw_state;
	extern float	this_sig_lr ();
	extern float	next_sig_lr ();

// dist_multi_sig_mr returns SIGASP_STOP if a trailing switch ahead stops the path to the
// following distant, giving an incorrect clear aspect. route_set only works on diverging  
// linked signals, therefore next_sig_lr is required to get the state of next home signal.
// The last distant before the trailing switch must have only one home before the switch.

	if ( 	!route_set () ||				// Switch not set as per link
		dist_multi_sig_mr (SIGFN_NORMAL, SIGFN_DISTANCE) !=# SIGASP_CLEAR_2 ||
		this_sig_lr (SIGFN_NORMAL) !=# SIGASP_CLEAR_2) // Home on this signal at danger
		
	{
		state = SIGASP_APPROACH_2;
	}
	else if ( next_sig_lr (SIGFN_NORMAL) !=# SIGASP_CLEAR_2) // Next Home Signal not clear
	{
		state = SIGASP_APPROACH_2;
	}
	else
	{
		state = SIGASP_CLEAR_2;
	}

// Get draw state
	draw_state = def_draw_state (state);


///////////////////////////////////////////////////////////////////////////////
SCRIPT SidingArm

// Siding Signal on Bracket

	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if (!enabled ||								// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR ||		// Block ahead not clear?
		!route_set())							// Switch not set as per link?
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_CLEAR_1;
	}

// Get draw state
	draw_state = def_draw_state (state);


///////////////////////////////////////////////////////////////////////////////
SCRIPT BRSemSide

// BR Siding Signal

	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

	if (!enabled ||								// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR ||		// Block ahead not clear?
		!route_set())							// Switch not set as per link?
	{
		state = SIGASP_STOP;
	}
	else
	{
		state = SIGASP_CLEAR_1;
	}

// Get draw state
	draw_state = def_draw_state (state);


///////////////////////////////////////////////////////////////////////////////
SCRIPT BRSemHomeBranch

// BR Semaphore Branch Home

	extern float	block_state ();
	extern float	route_set ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;

if(block_state()==#BLOCK_OCCUPIED&&TrainHasCallOn_Restricted()&&route_set() )
{
state = SIGASP_STOP_AND_PROCEED;
}
else if(block_state()!=#BLOCK_CLEAR||!enabled||!route_set())
{
state = SIGASP_STOP;
}
else 
{
state = SIGASP_CLEAR_2;
}

draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT UK3Light

// UK 3 light signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

if(block_state()==#BLOCK_OCCUPIED&&TrainHasCallOn_Restricted()&&route_set() )
{
state = SIGASP_STOP_AND_PROCEED;
}
else

if (block_state()!=#BLOCK_CLEAR||!enabled)
{
state = SIGASP_STOP;
}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else
      {
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP ||
			next_state ==# SIGASP_STOP_AND_PROCEED ||
			next_state ==# SIGASP_RESTRICTING)
		{
			state = SIGASP_APPROACH_1;
		}
		else if (next_state ==# SIGASP_APPROACH_1)
		{
			state = SIGASP_CLEAR_2;
		}
		else //if (next_state ==# SIGASP_APPROACH_2 ||
			//	next_state ==# SIGASP_CLEAR_2)
		{
			state = SIGASP_CLEAR_2;
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT UK3Lightauto

// RT 3 aspect auto signal

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

// If required, show the appropriate 'stop' indication.
	if ( // !enabled ||							// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR ||		// Block ahead not clear?
		!route_set())	// Switch not set as per link?
	{
		state = SIGASP_STOP;
	}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else
      {
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP ||
			next_state ==# SIGASP_STOP_AND_PROCEED ||
			next_state ==# SIGASP_RESTRICTING)
		{
			state = SIGASP_APPROACH_1;
		}
		else if (next_state ==# SIGASP_APPROACH_1)
		{
			state = SIGASP_CLEAR_2;
		}
		else //if (next_state ==# SIGASP_APPROACH_2 ||
			//	next_state ==# SIGASP_CLEAR_2)
		{
			state = SIGASP_CLEAR_2;
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT UK3LightRR

// UK 3 light signal head RR

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

if(block_state()==#BLOCK_OCCUPIED&&TrainHasCallOn_Restricted()&&route_set() )
{
state = SIGASP_STOP_AND_PROCEED;
}
else

if (block_state()!=#BLOCK_CLEAR||!enabled)
{
state = SIGASP_STOP;
}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else
      {
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP ||
			next_state ==# SIGASP_STOP_AND_PROCEED ||
			next_state ==# SIGASP_RESTRICTING)
		{
			state = SIGASP_APPROACH_1;
		}
		else if (next_state ==# SIGASP_APPROACH_1)
		{
			state = SIGASP_CLEAR_2;
		}
		else //if (next_state ==# SIGASP_APPROACH_2 ||
			//	next_state ==# SIGASP_CLEAR_2)
		{
			state = SIGASP_CLEAR_2;
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

	if (state ==# SIGASP_APPROACH_1 &&
		route_set())
	{
		draw_state = 3;		// (Draw state index from signal config)
	}
	else if (state ==# SIGASP_CLEAR_2 &&
		route_set()|| state==#SIGASP_STOP_AND_PROCEED)
	{
		draw_state = 4;		// (Draw state index from signal config)
	}

///////////////////////////////////////////////////////////////////////////////
SCRIPT UK3LightRL

// UK 3 light signal head RL


	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

if(block_state()==#BLOCK_OCCUPIED&&TrainHasCallOn_Restricted()&&route_set() )
{
state = SIGASP_STOP_AND_PROCEED;
}
else

if (block_state()!=#BLOCK_CLEAR||!enabled)
{
state = SIGASP_STOP;
}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else
      {
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP ||
			next_state ==# SIGASP_STOP_AND_PROCEED ||
			next_state ==# SIGASP_RESTRICTING)
		{
			state = SIGASP_APPROACH_1;
		}
		else if (next_state ==# SIGASP_APPROACH_1)
		{
			state = SIGASP_CLEAR_2;
		}
		else //if (next_state ==# SIGASP_APPROACH_2 ||
			//	next_state ==# SIGASP_CLEAR_2)
		{
			state = SIGASP_CLEAR_2;
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

	if (state ==# SIGASP_APPROACH_1 &&
		route_set())
	{
		draw_state = 3;		// (Draw state index from signal config)
	}
	else if (state ==# SIGASP_CLEAR_2 &&
		route_set()|| state==#SIGASP_STOP_AND_PROCEED)
	{
		draw_state = 4;		// (Draw state index from signal config)
	}

///////////////////////////////////////////////////////////////////////////////
SCRIPT UK4Light

// UK 4 light signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

if(block_state()==#BLOCK_OCCUPIED&&TrainHasCallOn_Restricted()&&route_set() )
{
state = SIGASP_STOP_AND_PROCEED;
}
else

if (block_state()!=#BLOCK_CLEAR||!enabled)
{
state = SIGASP_STOP;
}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP ||
			next_state ==# SIGASP_STOP_AND_PROCEED ||
			next_state ==# SIGASP_RESTRICTING)
		{
			state = SIGASP_APPROACH_1;
		}
		else if (next_state ==# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_2;
		}
		else //if (next_state ==# SIGASP_APPROACH_2 ||
			//	next_state ==# SIGASP_CLEAR_2)
		{
			state = SIGASP_CLEAR_2;
		}
	}

// Get draw state
	draw_state = def_draw_state (state);


///////////////////////////////////////////////////////////////////////////////
SCRIPT UK4Lightauto

// RT 4 aspect auto signal

	// Use SIG_EXTERNS 'macro' instead?..
	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;



// If required, show the appropriate 'stop' indication.
	if ( // !enabled ||							// Not enabled/cleared to show natural state?
		block_state() !=# BLOCK_CLEAR ||		// Block ahead not clear?
		!route_set())	// Switch not set as per link?
	{
		state = SIGASP_STOP;
	}

// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP ||
			next_state ==# SIGASP_STOP_AND_PROCEED ||
			next_state ==# SIGASP_RESTRICTING)
		{
			state = SIGASP_APPROACH_1;
		}
		else if (next_state ==# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_2;
		}
		else //if (next_state ==# SIGASP_APPROACH_2 ||
			//	next_state ==# SIGASP_CLEAR_2)
		{
			state = SIGASP_CLEAR_2;
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

///////////////////////////////////////////////////////////////////////////////
SCRIPT UK4LightRR

// UK 4 light signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

if(block_state()==#BLOCK_OCCUPIED&&TrainHasCallOn_Restricted()&&route_set() )
{
state = SIGASP_STOP_AND_PROCEED;
}
else

if (block_state()!=#BLOCK_CLEAR||!enabled)
{
state = SIGASP_STOP;
}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP ||
			next_state ==# SIGASP_STOP_AND_PROCEED ||
			next_state ==# SIGASP_RESTRICTING)
		{
			state = SIGASP_APPROACH_1;
		}
		else if (next_state ==# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_2;
		}
		else //if (next_state ==# SIGASP_APPROACH_2 ||
			//	next_state ==# SIGASP_CLEAR_2)
		{
			state = SIGASP_CLEAR_2;
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

	if (state ==# SIGASP_APPROACH_1 &&
		route_set())
	{
		draw_state = 4;		// (Draw state index from signal config)
	}
	else if (state ==# SIGASP_APPROACH_2 &&
		route_set())
	{
		draw_state = 5;		// (Draw state index from signal config)
	}
	else if (state ==# SIGASP_CLEAR_2 &&
		route_set()||state==#SIGASP_STOP_AND_PROCEED )
	{
		draw_state = 6;		// (Draw state index from signal config)
	}

///////////////////////////////////////////////////////////////////////////////
SCRIPT UK4LightRL

// UK 4 light signal head

	extern float	block_state ();
	extern float	route_set ();
	extern float	next_sig_lr ();
	extern float	def_draw_state ();
	extern float	state;
	extern float	draw_state;
	extern float	enabled;
	float			next_state;

if(block_state()==#BLOCK_OCCUPIED&&TrainHasCallOn_Restricted()&&route_set() )
{
state = SIGASP_STOP_AND_PROCEED;
}
else

if (block_state()!=#BLOCK_CLEAR||!enabled)
{
state = SIGASP_STOP;
}
// Signal head is enabled and the block ahead is clear - update based on state of
// next signal head.
	else
	{
		next_state = next_sig_lr (SIGFN_NORMAL);

		if (next_state ==# SIGASP_STOP ||
			next_state ==# SIGASP_STOP_AND_PROCEED ||
			next_state ==# SIGASP_RESTRICTING)
		{
			state = SIGASP_APPROACH_1;
		}
		else if (next_state ==# SIGASP_APPROACH_1)
		{
			state = SIGASP_APPROACH_2;
		}
		else //if (next_state ==# SIGASP_APPROACH_2 ||
			//	next_state ==# SIGASP_CLEAR_2)
		{
			state = SIGASP_CLEAR_2;
		}
	}

// Get draw state
	draw_state = def_draw_state (state);

if (state ==# SIGASP_APPROACH_1 &&
		route_set())
	{
		draw_state = 4;		// (Draw state index from signal config)
	}
	else if (state ==# SIGASP_APPROACH_2 &&
		route_set())
	{
		draw_state = 5;		// (Draw state index from signal config)
	}
	else if (state ==# SIGASP_CLEAR_2 &&
		route_set()||state==#SIGASP_STOP_AND_PROCEED )
	{
		draw_state = 6;		// (Draw state index from signal config)
	}
///////////////////////////////////////////////////////////////////////////////

// End of File
